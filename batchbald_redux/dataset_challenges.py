# AUTOGENERATED! DO NOT EDIT! File to edit: 05d_dataset_challenges.ipynb (unless otherwise specified).

__all__ = ['override_labels', 'corrupt_labels', 'corrupt_all_labels', 'get_class_indices', 'get_imbalanced_dataset',
           'add_ood_dataset']

# Cell

import numpy as np
import torch
import torch.utils.data as data

from .repeated_mnist import TransformedDataset

# Cell


def override_labels(dataset: data.Dataset, indices: list, new_labels: list):
    indices_set = set(indices)
    reverse_indices = {idx: rank for rank, idx in enumerate(indices)}

    def override_label(idx, data):
        if idx not in indices_set:
            return data

        x, y = data
        ridx = reverse_indices[idx]
        new_y = new_labels[ridx]
        return x, new_y

    return TransformedDataset(dataset, transformer=override_label)


def corrupt_labels(
    dataset: data.Dataset, *, percentage: int, num_classes: int, generator: np.random.Generator, device=None
):
    N = len(dataset)
    num_corrupted = N * percentage // 100

    indices = generator.choice(N, size=num_corrupted, replace=False)
    new_labels = generator.choice(num_classes, size=num_corrupted, replace=True)

    updated_dataset = override_labels(dataset, indices, torch.as_tensor(new_labels, device=device))

    return updated_dataset


def corrupt_all_labels(dataset: data.Dataset, *, num_classes: int, generator: np.random.Generator, device=None):
    N = len(dataset)

    new_labels = torch.as_tensor(generator.choice(num_classes, size=N, replace=True), device=device)

    def override_label(idx, data):
        x, _ = data
        y = new_labels[idx]
        return x, y

    return TransformedDataset(dataset, transformer=override_label)

# Cell


def get_class_indices(dataset: data.Dataset, *, class_counts: list, generator: np.random.Generator):
    class_counts = list(class_counts)

    subset_indices = []

    remaining_samples = sum(class_counts)

    indices = generator.choice(len(dataset), size=remaining_samples, replace=False)
    for index in indices:
        _, y = dataset[index]

        if class_counts[y] > 0:
            subset_indices.append(index)
            class_counts[y] -= 1

    return subset_indices


def get_imbalanced_dataset(dataset: data.Dataset, *, class_counts: list, generator: np.random.Generator):
    subset_indices = get_class_indices(dataset, class_counts=class_counts, generator=generator)

    return data.Subset(dataset, subset_indices)

# Cell


def add_ood_dataset(
    *,
    dataset: data.Dataset,
    ood_dataset: data.Dataset,
    ood_percentage: int,
    ood_random_labels: bool,
    generator: np.random.Generator,
    num_classes=None,
    device=None
):
    subset_ood_N = len(dataset) * ood_percentage // 100

    ood_N = len(ood_dataset)
    assert subset_ood_N <= ood_N

    ood_indices = generator.choice(ood_N, size=subset_ood_N, replace=False)

    ood_subset = data.Subset(ood_dataset, torch.as_tensor(ood_indices, device=device))

    if ood_random_labels:
        assert num_classes
        ood_subset = corrupt_all_labels(ood_subset, num_classes=num_classes, generator=generator, device=device)

    return data.ConcatDataset((dataset, ood_subset))
---

title: Acquisition Function: EPIG


keywords: fastai
sidebar: home_sidebar

summary: "Greedy algorithm and score computation"
description: "Greedy algorithm and score computation"
nb_path: "01e_acquisition_function_epig.ipynb"
---
<!--

#################################################
### THIS FILE WAS AUTOGENERATED! DO NOT EDIT! ###
#################################################
# file to edit: 01e_acquisition_function_epig.ipynb
# command to build the docs after a change: nbdev_build_docs

-->

<div class="container" id="notebook-container">
        
    {% raw %}
    
<div class="cell border-box-sizing code_cell rendered">

</div>
    {% endraw %}

<div class="cell border-box-sizing text_cell rendered"><div class="inner_cell">
<div class="text_cell_render border-box-sizing rendered_html">
<p>First, we will implement two helper classes to compute conditional entropies $H[y_i|w]$ and entropies $H[y_i]$. 
Then, we will implement BatchBALD and BALD.</p>

</div>
</div>
</div>
    {% raw %}
    
<div class="cell border-box-sizing code_cell rendered">
<div class="input">

<div class="inner_cell">
    <div class="input_area">
<div class=" highlight hl-ipython3"><pre><span></span><span class="kn">import</span> <span class="nn">math</span>

<span class="kn">import</span> <span class="nn">numpy</span> <span class="k">as</span> <span class="nn">np</span>
<span class="kn">import</span> <span class="nn">torch</span>
<span class="kn">from</span> <span class="nn">blackhc.progress_bar</span> <span class="kn">import</span> <span class="n">create_progress_bar</span>
<span class="kn">from</span> <span class="nn">toma</span> <span class="kn">import</span> <span class="n">toma</span>

<span class="kn">from</span> <span class="nn">batchbald_redux.acquisition_functions.epig</span> <span class="kn">import</span> <span class="o">*</span> 
<span class="kn">from</span> <span class="nn">batchbald_redux.joint_entropy</span> <span class="kn">import</span> <span class="o">*</span>
</pre></div>

    </div>
</div>
</div>

</div>
    {% endraw %}

<div class="cell border-box-sizing text_cell rendered"><div class="inner_cell">
<div class="text_cell_render border-box-sizing rendered_html">
<p>We are going to define a couple of sampled distributions to use for our testing our code.</p>
<p>$K=20$ means 20 inference samples.</p>

</div>
</div>
</div>
    {% raw %}
    
<div class="cell border-box-sizing code_cell rendered">
<div class="input">

<div class="inner_cell">
    <div class="input_area">
<div class=" highlight hl-ipython3"><pre><span></span><span class="n">K</span> <span class="o">=</span> <span class="mi">20</span>
</pre></div>

    </div>
</div>
</div>

</div>
    {% endraw %}

    {% raw %}
    
<div class="cell border-box-sizing code_cell rendered">
<div class="input">

<div class="inner_cell">
    <div class="input_area">
<div class=" highlight hl-ipython3"><pre><span></span><span class="k">def</span> <span class="nf">get_mixture_prob_dist</span><span class="p">(</span><span class="n">p1</span><span class="p">,</span> <span class="n">p2</span><span class="p">,</span> <span class="n">m</span><span class="p">):</span>
    <span class="k">return</span> <span class="p">(</span><span class="mf">1.0</span> <span class="o">-</span> <span class="n">m</span><span class="p">)</span> <span class="o">*</span> <span class="n">np</span><span class="o">.</span><span class="n">asarray</span><span class="p">(</span><span class="n">p1</span><span class="p">)</span> <span class="o">+</span> <span class="n">m</span> <span class="o">*</span> <span class="n">np</span><span class="o">.</span><span class="n">asarray</span><span class="p">(</span><span class="n">p2</span><span class="p">)</span>


<span class="n">p1</span> <span class="o">=</span> <span class="p">[</span><span class="mf">0.7</span><span class="p">,</span> <span class="mf">0.1</span><span class="p">,</span> <span class="mf">0.1</span><span class="p">,</span> <span class="mf">0.1</span><span class="p">]</span>
<span class="n">p2</span> <span class="o">=</span> <span class="p">[</span><span class="mf">0.3</span><span class="p">,</span> <span class="mf">0.3</span><span class="p">,</span> <span class="mf">0.2</span><span class="p">,</span> <span class="mf">0.2</span><span class="p">]</span>
<span class="n">y1_ws</span> <span class="o">=</span> <span class="p">[</span><span class="n">get_mixture_prob_dist</span><span class="p">(</span><span class="n">p1</span><span class="p">,</span> <span class="n">p2</span><span class="p">,</span> <span class="n">m</span><span class="p">)</span> <span class="k">for</span> <span class="n">m</span> <span class="ow">in</span> <span class="n">np</span><span class="o">.</span><span class="n">linspace</span><span class="p">(</span><span class="mi">0</span><span class="p">,</span> <span class="mi">1</span><span class="p">,</span> <span class="n">K</span><span class="p">)]</span>

<span class="n">p1</span> <span class="o">=</span> <span class="p">[</span><span class="mf">0.1</span><span class="p">,</span> <span class="mf">0.7</span><span class="p">,</span> <span class="mf">0.1</span><span class="p">,</span> <span class="mf">0.1</span><span class="p">]</span>
<span class="n">p2</span> <span class="o">=</span> <span class="p">[</span><span class="mf">0.2</span><span class="p">,</span> <span class="mf">0.3</span><span class="p">,</span> <span class="mf">0.3</span><span class="p">,</span> <span class="mf">0.2</span><span class="p">]</span>
<span class="n">y2_ws</span> <span class="o">=</span> <span class="p">[</span><span class="n">get_mixture_prob_dist</span><span class="p">(</span><span class="n">p1</span><span class="p">,</span> <span class="n">p2</span><span class="p">,</span> <span class="n">m</span><span class="p">)</span> <span class="k">for</span> <span class="n">m</span> <span class="ow">in</span> <span class="n">np</span><span class="o">.</span><span class="n">linspace</span><span class="p">(</span><span class="mi">0</span><span class="p">,</span> <span class="mi">1</span><span class="p">,</span> <span class="n">K</span><span class="p">)]</span>

<span class="n">p1</span> <span class="o">=</span> <span class="p">[</span><span class="mf">0.1</span><span class="p">,</span> <span class="mf">0.1</span><span class="p">,</span> <span class="mf">0.7</span><span class="p">,</span> <span class="mf">0.1</span><span class="p">]</span>
<span class="n">p2</span> <span class="o">=</span> <span class="p">[</span><span class="mf">0.2</span><span class="p">,</span> <span class="mf">0.2</span><span class="p">,</span> <span class="mf">0.3</span><span class="p">,</span> <span class="mf">0.3</span><span class="p">]</span>
<span class="n">y3_ws</span> <span class="o">=</span> <span class="p">[</span><span class="n">get_mixture_prob_dist</span><span class="p">(</span><span class="n">p1</span><span class="p">,</span> <span class="n">p2</span><span class="p">,</span> <span class="n">m</span><span class="p">)</span> <span class="k">for</span> <span class="n">m</span> <span class="ow">in</span> <span class="n">np</span><span class="o">.</span><span class="n">linspace</span><span class="p">(</span><span class="mi">0</span><span class="p">,</span> <span class="mi">1</span><span class="p">,</span> <span class="n">K</span><span class="p">)]</span>

<span class="n">p1</span> <span class="o">=</span> <span class="p">[</span><span class="mf">0.1</span><span class="p">,</span> <span class="mf">0.1</span><span class="p">,</span> <span class="mf">0.1</span><span class="p">,</span> <span class="mf">0.7</span><span class="p">]</span>
<span class="n">p2</span> <span class="o">=</span> <span class="p">[</span><span class="mf">0.3</span><span class="p">,</span> <span class="mf">0.2</span><span class="p">,</span> <span class="mf">0.2</span><span class="p">,</span> <span class="mf">0.3</span><span class="p">]</span>
<span class="n">y4_ws</span> <span class="o">=</span> <span class="p">[</span><span class="n">get_mixture_prob_dist</span><span class="p">(</span><span class="n">p1</span><span class="p">,</span> <span class="n">p2</span><span class="p">,</span> <span class="n">m</span><span class="p">)</span> <span class="k">for</span> <span class="n">m</span> <span class="ow">in</span> <span class="n">np</span><span class="o">.</span><span class="n">linspace</span><span class="p">(</span><span class="mi">0</span><span class="p">,</span> <span class="mi">1</span><span class="p">,</span> <span class="n">K</span><span class="p">)]</span>


<span class="k">def</span> <span class="nf">nested_to_tensor</span><span class="p">(</span><span class="n">l</span><span class="p">):</span>
    <span class="k">return</span> <span class="n">torch</span><span class="o">.</span><span class="n">stack</span><span class="p">(</span><span class="nb">list</span><span class="p">(</span><span class="nb">map</span><span class="p">(</span><span class="n">torch</span><span class="o">.</span><span class="n">as_tensor</span><span class="p">,</span> <span class="n">l</span><span class="p">)))</span>


<span class="n">ys_ws</span> <span class="o">=</span> <span class="n">nested_to_tensor</span><span class="p">([</span><span class="n">y1_ws</span><span class="p">,</span> <span class="n">y2_ws</span><span class="p">,</span> <span class="n">y3_ws</span><span class="p">,</span> <span class="n">y4_ws</span><span class="p">])</span>
</pre></div>

    </div>
</div>
</div>

</div>
    {% endraw %}

    {% raw %}
    
<div class="cell border-box-sizing code_cell rendered">
<div class="input">

<div class="inner_cell">
    <div class="input_area">
<div class=" highlight hl-ipython3"><pre><span></span><span class="n">ys_ws</span><span class="o">.</span><span class="n">shape</span>
</pre></div>

    </div>
</div>
</div>

<div class="output_wrapper">
<div class="output">

<div class="output_area">



<div class="output_text output_subarea output_execute_result">
<pre>torch.Size([4, 20, 4])</pre>
</div>

</div>

</div>
</div>

</div>
    {% endraw %}

<div class="cell border-box-sizing text_cell rendered"><div class="inner_cell">
<div class="text_cell_render border-box-sizing rendered_html">
<p>However, our neural networks usually use a <code>log_softmax</code> as final layer. To avoid having to call <code>.exp_()</code>, which is easy to miss and annoying to debug, we will instead use a version that uses <code>log_probs</code> instead of <code>probs</code>.</p>

</div>
</div>
</div>
<div class="cell border-box-sizing text_cell rendered"><div class="inner_cell">
<div class="text_cell_render border-box-sizing rendered_html">
<h3 id="Examples">Examples<a class="anchor-link" href="#Examples"> </a></h3>
</div>
</div>
</div>
    {% raw %}
    
<div class="cell border-box-sizing code_cell rendered">
<div class="input">

<div class="inner_cell">
    <div class="input_area">
<div class=" highlight hl-ipython3"><pre><span></span><span class="n">conditional_entropies</span> <span class="o">=</span> <span class="n">compute_conditional_entropy</span><span class="p">(</span><span class="n">ys_ws</span><span class="o">.</span><span class="n">log</span><span class="p">())</span>

<span class="nb">print</span><span class="p">(</span><span class="n">conditional_entropies</span><span class="p">)</span>

<span class="k">assert</span> <span class="n">np</span><span class="o">.</span><span class="n">allclose</span><span class="p">(</span><span class="n">conditional_entropies</span><span class="p">,</span> <span class="p">[</span><span class="mf">1.2069</span><span class="p">,</span> <span class="mf">1.2069</span><span class="p">,</span> <span class="mf">1.2069</span><span class="p">,</span> <span class="mf">1.2069</span><span class="p">],</span> <span class="n">atol</span><span class="o">=</span><span class="mf">0.01</span><span class="p">)</span>
</pre></div>

    </div>
</div>
</div>

<div class="output_wrapper">
<div class="output">

<div class="output_area">

<div class="output_subarea output_stream output_stdout output_text">
<pre>tensor([1.2069, 1.2069, 1.2069, 1.2069], dtype=torch.float64)
</pre>
</div>
</div>

</div>
</div>

</div>
    {% endraw %}

    {% raw %}
    
<div class="cell border-box-sizing code_cell rendered">
<div class="input">

<div class="inner_cell">
    <div class="input_area">
<div class=" highlight hl-ipython3"><pre><span></span><span class="n">entropies</span> <span class="o">=</span> <span class="n">compute_entropy</span><span class="p">(</span><span class="n">ys_ws</span><span class="o">.</span><span class="n">log</span><span class="p">())</span>

<span class="nb">print</span><span class="p">(</span><span class="n">entropies</span><span class="p">)</span>

<span class="k">assert</span> <span class="n">np</span><span class="o">.</span><span class="n">allclose</span><span class="p">(</span><span class="n">entropies</span><span class="p">,</span> <span class="p">[</span><span class="mf">1.2376</span><span class="p">,</span> <span class="mf">1.2376</span><span class="p">,</span> <span class="mf">1.2376</span><span class="p">,</span> <span class="mf">1.2376</span><span class="p">],</span> <span class="n">atol</span><span class="o">=</span><span class="mf">0.01</span><span class="p">)</span>
</pre></div>

    </div>
</div>
</div>

<div class="output_wrapper">
<div class="output">

<div class="output_area">

<div class="output_subarea output_stream output_stdout output_text">
<pre>tensor([1.2376, 1.2376, 1.2376, 1.2376], dtype=torch.float64)
</pre>
</div>
</div>

</div>
</div>

</div>
    {% endraw %}

<div class="cell border-box-sizing text_cell rendered"><div class="inner_cell">
<div class="text_cell_render border-box-sizing rendered_html">
<h2 id="EPIG-BALD">EPIG-BALD<a class="anchor-link" href="#EPIG-BALD"> </a></h2><p>The computation for EPIG-BALD is simple. We need to keep track of two separate (Batch)BALD terms:</p>
<p>{% raw %}
$$\mathrm{I}\left[(y)_{B} ; \omega \mid(x)_{B}, D_{T}\right]-\mathrm{I}\left[(y)_{B} ; \omega \mid(x)_{B}, D_{U} \cup D_{T}\right].$$
{% endraw %}</p>

</div>
</div>
</div>
<div class="cell border-box-sizing text_cell rendered"><div class="inner_cell">
<div class="text_cell_render border-box-sizing rendered_html">
<h3 id="Example">Example<a class="anchor-link" href="#Example"> </a></h3>
</div>
</div>
</div>
<div class="cell border-box-sizing text_cell rendered"><div class="inner_cell">
<div class="text_cell_render border-box-sizing rendered_html">
<h4 id="Pleasing-example-of-the-case-when-predictions-match-(full-overlap)">Pleasing example of the case when predictions match (full overlap)<a class="anchor-link" href="#Pleasing-example-of-the-case-when-predictions-match-(full-overlap)"> </a></h4>
</div>
</div>
</div>
    {% raw %}
    
<div class="cell border-box-sizing code_cell rendered">
<div class="input">

<div class="inner_cell">
    <div class="input_area">
<div class=" highlight hl-ipython3"><pre><span></span><span class="n">get_batch_eval_bald_batch</span><span class="p">(</span>
    <span class="n">ys_ws</span><span class="o">.</span><span class="n">log</span><span class="p">()</span><span class="o">.</span><span class="n">double</span><span class="p">(),</span> <span class="n">ys_ws</span><span class="o">.</span><span class="n">log</span><span class="p">()</span><span class="o">.</span><span class="n">double</span><span class="p">(),</span> <span class="n">batch_size</span><span class="o">=</span><span class="mi">4</span><span class="p">,</span> <span class="n">num_samples</span><span class="o">=</span><span class="mi">1000</span><span class="p">,</span> <span class="n">dtype</span><span class="o">=</span><span class="n">torch</span><span class="o">.</span><span class="n">double</span>
<span class="p">)</span>
</pre></div>

    </div>
</div>
</div>

<div class="output_wrapper">
<div class="output">

<div class="output_area">



<div class="output_text output_subarea output_execute_result">
<pre>CandidateBatch(scores=[0.0, 0.0, 0.0, 0.0], indices=[0, 1, 2, 3])</pre>
</div>

</div>

</div>
</div>

</div>
    {% endraw %}

    {% raw %}
    
<div class="cell border-box-sizing code_cell rendered">
<div class="input">

<div class="inner_cell">
    <div class="input_area">
<div class=" highlight hl-ipython3"><pre><span></span><span class="n">get_batch_eval_bald_batch</span><span class="p">(</span>
    <span class="n">ys_ws</span><span class="o">.</span><span class="n">log</span><span class="p">()</span><span class="o">.</span><span class="n">double</span><span class="p">(),</span> <span class="n">torch</span><span class="o">.</span><span class="n">zeros_like</span><span class="p">(</span><span class="n">ys_ws</span><span class="p">)</span><span class="o">.</span><span class="n">double</span><span class="p">(),</span> <span class="n">batch_size</span><span class="o">=</span><span class="mi">4</span><span class="p">,</span> <span class="n">num_samples</span><span class="o">=</span><span class="mi">1000</span><span class="p">,</span> <span class="n">dtype</span><span class="o">=</span><span class="n">torch</span><span class="o">.</span><span class="n">double</span>
<span class="p">)</span>
</pre></div>

    </div>
</div>
</div>

<div class="output_wrapper">
<div class="output">

<div class="output_area">



<div class="output_text output_subarea output_execute_result">
<pre>CandidateBatch(scores=[0.030715639666234917, 0.05961958627158248, 0.0869107051474467, 0.11275304532467878], indices=[1, 0, 2, 3])</pre>
</div>

</div>

</div>
</div>

</div>
    {% endraw %}

<div class="cell border-box-sizing text_cell rendered"><div class="inner_cell">
<div class="text_cell_render border-box-sizing rendered_html">
<h2 id="Additional-EPIG-BALD-variants">Additional EPIG-BALD variants<a class="anchor-link" href="#Additional-EPIG-BALD-variants"> </a></h2><p>Instead of using BatchBALD, let's compute BALD directly and use either the top-k, TopRandom or Thomp</p>

</div>
</div>
</div>
    {% raw %}
    
<div class="cell border-box-sizing code_cell rendered">
<div class="input">

<div class="inner_cell">
    <div class="input_area">
<div class=" highlight hl-ipython3"><pre><span></span><span class="n">get_eval_bald_batch</span><span class="p">(</span><span class="n">ys_ws</span><span class="o">.</span><span class="n">log</span><span class="p">()</span><span class="o">.</span><span class="n">double</span><span class="p">(),</span> <span class="n">ys_ws</span><span class="o">.</span><span class="n">log</span><span class="p">()</span><span class="o">.</span><span class="n">double</span><span class="p">(),</span> <span class="n">batch_size</span><span class="o">=</span><span class="mi">4</span><span class="p">,</span> <span class="n">dtype</span><span class="o">=</span><span class="n">torch</span><span class="o">.</span><span class="n">double</span><span class="p">)</span>
</pre></div>

    </div>
</div>
</div>

<div class="output_wrapper">
<div class="output">

<div class="output_area">



<div class="output_text output_subarea output_execute_result">
<pre>CandidateBatch(scores=[0.0, 0.0, 0.0, 0.0], indices=[2, 3, 0, 1])</pre>
</div>

</div>

</div>
</div>

</div>
    {% endraw %}

    {% raw %}
    
<div class="cell border-box-sizing code_cell rendered">
<div class="input">

<div class="inner_cell">
    <div class="input_area">
<div class=" highlight hl-ipython3"><pre><span></span><span class="n">get_top_random_eval_bald_batch</span><span class="p">(</span>
    <span class="n">ys_ws</span><span class="o">.</span><span class="n">log</span><span class="p">()</span><span class="o">.</span><span class="n">double</span><span class="p">(),</span> <span class="n">ys_ws</span><span class="o">.</span><span class="n">log</span><span class="p">()</span><span class="o">.</span><span class="n">double</span><span class="p">(),</span> <span class="n">batch_size</span><span class="o">=</span><span class="mi">4</span><span class="p">,</span> <span class="n">num_classes</span><span class="o">=</span><span class="mi">10</span><span class="p">,</span> <span class="n">dtype</span><span class="o">=</span><span class="n">torch</span><span class="o">.</span><span class="n">double</span>
<span class="p">)</span>
</pre></div>

    </div>
</div>
</div>

<div class="output_wrapper">
<div class="output">

<div class="output_area">



<div class="output_text output_subarea output_execute_result">
<pre>CandidateBatch(scores=[0.0, 0.0, 0.0, 0.0], indices=[1, 0, 3, 2])</pre>
</div>

</div>

</div>
</div>

</div>
    {% endraw %}

<div class="cell border-box-sizing text_cell rendered"><div class="inner_cell">
<div class="text_cell_render border-box-sizing rendered_html">
<h2 id="EPIG">EPIG<a class="anchor-link" href="#EPIG"> </a></h2><p>As part of an ablation (and to see how it performs), we can also compute the ICAL score.</p>

</div>
</div>
</div>
    {% raw %}
    
<div class="cell border-box-sizing code_cell rendered">
<div class="input">

<div class="inner_cell">
    <div class="input_area">
<div class=" highlight hl-ipython3"><pre><span></span><span class="n">get_eig_scores</span><span class="p">(</span><span class="n">ys_ws</span><span class="o">.</span><span class="n">log</span><span class="p">()</span><span class="o">.</span><span class="n">double</span><span class="p">(),</span> <span class="n">ys_ws</span><span class="o">.</span><span class="n">log</span><span class="p">()</span><span class="o">.</span><span class="n">double</span><span class="p">())</span>
</pre></div>

    </div>
</div>
</div>

<div class="output_wrapper">
<div class="output">

<div class="output_area">



<div class="output_text output_subarea output_execute_result">
<pre>tensor([0., 0., 0., 0.], dtype=torch.float64)</pre>
</div>

</div>

</div>
</div>

</div>
    {% endraw %}

    {% raw %}
    
<div class="cell border-box-sizing code_cell rendered">
<div class="input">

<div class="inner_cell">
    <div class="input_area">
<div class=" highlight hl-ipython3"><pre><span></span><span class="n">get_batch_eig_batch</span><span class="p">(</span><span class="n">ys_ws</span><span class="o">.</span><span class="n">log</span><span class="p">()</span><span class="o">.</span><span class="n">double</span><span class="p">(),</span> <span class="n">ys_ws</span><span class="o">.</span><span class="n">log</span><span class="p">()</span><span class="o">.</span><span class="n">double</span><span class="p">(),</span> <span class="n">batch_size</span><span class="o">=</span><span class="mi">4</span><span class="p">,</span> <span class="n">num_samples</span><span class="o">=</span><span class="mi">1000</span><span class="p">,</span> <span class="n">dtype</span><span class="o">=</span><span class="n">torch</span><span class="o">.</span><span class="n">double</span><span class="p">)</span>
</pre></div>

    </div>
</div>
</div>

<div class="output_wrapper">
<div class="output">

<div class="output_area">



<div class="output_text output_subarea output_execute_result">
<pre>CandidateBatch(scores=[0.0, 0.0, 0.0, 0.0], indices=[0, 1, 2, 3])</pre>
</div>

</div>

</div>
</div>

</div>
    {% endraw %}

<div class="cell border-box-sizing text_cell rendered"><div class="inner_cell">
<div class="text_cell_render border-box-sizing rendered_html">
<h2 id="Real-EPIG">Real EPIG<a class="anchor-link" href="#Real-EPIG"> </a></h2><p>Implement $I[Y_{acq} ; Y_{eval} \mid x_{acq} ; X_{eval},  D_{train}]$.</p>

</div>
</div>
</div>
    {% raw %}
    
<div class="cell border-box-sizing code_cell rendered">
<div class="input">

<div class="inner_cell">
    <div class="input_area">
<div class=" highlight hl-ipython3"><pre><span></span><span class="k">def</span> <span class="nf">get_joint_probs_N_C_C_old</span><span class="p">(</span><span class="n">pool_probs_N_K_C</span><span class="p">:</span> <span class="n">torch</span><span class="o">.</span><span class="n">Tensor</span><span class="p">,</span> <span class="n">single_eval_probs_K_C</span><span class="p">:</span> <span class="n">torch</span><span class="o">.</span><span class="n">Tensor</span><span class="p">):</span>
    <span class="n">K</span> <span class="o">=</span> <span class="n">single_eval_probs_K_C</span><span class="o">.</span><span class="n">shape</span><span class="p">[</span><span class="mi">0</span><span class="p">]</span>

    <span class="n">pool_log_probs_N_C_K</span> <span class="o">=</span> <span class="n">pool_probs_N_K_C</span><span class="o">.</span><span class="n">transpose</span><span class="p">(</span><span class="mi">1</span><span class="p">,</span> <span class="mi">2</span><span class="p">)</span>
    <span class="n">joint_probs_N_C_C</span> <span class="o">=</span> <span class="n">pool_log_probs_N_C_K</span> <span class="o">@</span> <span class="n">single_eval_probs_K_C</span> <span class="o">/</span> <span class="n">K</span>
    <span class="k">return</span> <span class="n">joint_probs_N_C_C</span>


<span class="k">def</span> <span class="nf">get_real_naive_epig_scores_old</span><span class="p">(</span>
    <span class="o">*</span><span class="p">,</span> <span class="n">pool_log_probs_N_K_C</span><span class="p">:</span> <span class="n">torch</span><span class="o">.</span><span class="n">Tensor</span><span class="p">,</span> <span class="n">eval_log_probs_E_K_C</span><span class="p">:</span> <span class="n">torch</span><span class="o">.</span><span class="n">Tensor</span><span class="p">,</span> <span class="n">dtype</span><span class="o">=</span><span class="kc">None</span><span class="p">,</span> <span class="n">device</span><span class="o">=</span><span class="kc">None</span>
<span class="p">)</span> <span class="o">-&gt;</span> <span class="n">torch</span><span class="o">.</span><span class="n">Tensor</span><span class="p">:</span>
    <span class="sd">&quot;&quot;&quot;Implements naive EPIG: I[Y_acq; Y_eval | x_acq, X_eval].&quot;&quot;&quot;</span>
    <span class="n">N</span><span class="p">,</span> <span class="n">K</span><span class="p">,</span> <span class="n">C</span> <span class="o">=</span> <span class="n">pool_log_probs_N_K_C</span><span class="o">.</span><span class="n">shape</span>
    <span class="n">E</span><span class="p">,</span> <span class="n">_</span><span class="p">,</span> <span class="n">_</span> <span class="o">=</span> <span class="n">eval_log_probs_E_K_C</span><span class="o">.</span><span class="n">shape</span>
    <span class="k">assert</span> <span class="p">(</span>
        <span class="n">pool_log_probs_N_K_C</span><span class="o">.</span><span class="n">shape</span><span class="p">[</span><span class="mi">1</span><span class="p">:]</span> <span class="o">==</span> <span class="n">pool_log_probs_N_K_C</span><span class="o">.</span><span class="n">shape</span><span class="p">[</span><span class="mi">1</span><span class="p">:]</span>
    <span class="p">),</span> <span class="s2">&quot;</span><span class="si">{pool_log_probs_N_K_C.shape[1:]}</span><span class="s2"> != </span><span class="si">{pool_log_probs_N_K_C.shape[1:]}</span><span class="s2">&quot;</span>

    <span class="n">pool_probs_N_K_C</span> <span class="o">=</span> <span class="n">pool_log_probs_N_K_C</span><span class="o">.</span><span class="n">to</span><span class="p">(</span><span class="n">dtype</span><span class="o">=</span><span class="n">dtype</span><span class="p">,</span> <span class="n">device</span><span class="o">=</span><span class="n">device</span><span class="p">)</span><span class="o">.</span><span class="n">exp</span><span class="p">()</span>
    <span class="n">eval_probs_E_K_C</span> <span class="o">=</span> <span class="n">eval_log_probs_E_K_C</span><span class="o">.</span><span class="n">to</span><span class="p">(</span><span class="n">dtype</span><span class="o">=</span><span class="n">dtype</span><span class="p">,</span> <span class="n">device</span><span class="o">=</span><span class="n">device</span><span class="p">)</span><span class="o">.</span><span class="n">exp</span><span class="p">()</span>

    <span class="n">pool_probs_N_C</span> <span class="o">=</span> <span class="n">torch</span><span class="o">.</span><span class="n">mean</span><span class="p">(</span><span class="n">pool_probs_N_K_C</span><span class="p">,</span> <span class="n">dim</span><span class="o">=</span><span class="mi">1</span><span class="p">,</span> <span class="n">keepdim</span><span class="o">=</span><span class="kc">False</span><span class="p">)</span>

    <span class="n">total_scores_N</span> <span class="o">=</span> <span class="n">torch</span><span class="o">.</span><span class="n">zeros</span><span class="p">((</span><span class="n">N</span><span class="p">,),</span> <span class="n">dtype</span><span class="o">=</span><span class="n">dtype</span><span class="p">,</span> <span class="n">device</span><span class="o">=</span><span class="s2">&quot;cpu&quot;</span><span class="p">)</span>
    <span class="k">for</span> <span class="n">i_e</span> <span class="ow">in</span> <span class="n">with_progress_bar</span><span class="p">(</span><span class="nb">range</span><span class="p">(</span><span class="n">E</span><span class="p">),</span> <span class="n">tqdm_args</span><span class="o">=</span><span class="nb">dict</span><span class="p">(</span><span class="n">desc</span><span class="o">=</span><span class="s2">&quot;Evaluation Set&quot;</span><span class="p">,</span> <span class="n">leave</span><span class="o">=</span><span class="kc">False</span><span class="p">)):</span>
        <span class="n">single_eval_probs_K_C</span> <span class="o">=</span> <span class="n">eval_probs_E_K_C</span><span class="p">[</span><span class="n">i_e</span><span class="p">]</span>

        <span class="n">joint_probs_N_C_C</span> <span class="o">=</span> <span class="n">get_joint_probs_N_C_C_old</span><span class="p">(</span><span class="n">pool_probs_N_K_C</span><span class="p">,</span> <span class="n">single_eval_probs_K_C</span><span class="p">)</span>

        <span class="n">single_eval_probs_C</span> <span class="o">=</span> <span class="n">torch</span><span class="o">.</span><span class="n">mean</span><span class="p">(</span><span class="n">single_eval_probs_K_C</span><span class="p">,</span> <span class="n">dim</span><span class="o">=</span><span class="mi">0</span><span class="p">,</span> <span class="n">keepdim</span><span class="o">=</span><span class="kc">False</span><span class="p">)</span>

        <span class="n">nats_N_C_C</span> <span class="o">=</span> <span class="p">(</span>
            <span class="o">-</span><span class="n">torch</span><span class="o">.</span><span class="n">log</span><span class="p">(</span><span class="n">single_eval_probs_C</span><span class="p">)[</span><span class="kc">None</span><span class="p">,</span> <span class="kc">None</span><span class="p">,</span> <span class="p">:]</span>
            <span class="o">-</span> <span class="n">torch</span><span class="o">.</span><span class="n">log</span><span class="p">(</span><span class="n">pool_probs_N_C</span><span class="p">)[:,</span> <span class="p">:,</span> <span class="kc">None</span><span class="p">]</span>
            <span class="o">+</span> <span class="n">torch</span><span class="o">.</span><span class="n">log</span><span class="p">(</span><span class="n">joint_probs_N_C_C</span><span class="p">)</span>
        <span class="p">)</span>

        <span class="n">weighted_nats_N_C_C</span> <span class="o">=</span> <span class="n">nats_N_C_C</span> <span class="o">*</span> <span class="n">joint_probs_N_C_C</span>
        <span class="n">weighted_nats_N_C_C</span><span class="p">[</span><span class="n">torch</span><span class="o">.</span><span class="n">isnan</span><span class="p">(</span><span class="n">weighted_nats_N_C_C</span><span class="p">)]</span> <span class="o">=</span> <span class="mf">0.0</span>
        <span class="n">scores_N</span> <span class="o">=</span> <span class="n">weighted_nats_N_C_C</span><span class="o">.</span><span class="n">sum</span><span class="p">((</span><span class="mi">1</span><span class="p">,</span> <span class="mi">2</span><span class="p">),</span> <span class="n">keepdim</span><span class="o">=</span><span class="kc">False</span><span class="p">)</span>

        <span class="n">total_scores_N</span> <span class="o">+=</span> <span class="n">scores_N</span><span class="o">.</span><span class="n">to</span><span class="p">(</span><span class="n">device</span><span class="o">=</span><span class="s2">&quot;cpu&quot;</span><span class="p">,</span> <span class="n">non_blocking</span><span class="o">=</span><span class="kc">True</span><span class="p">)</span>

    <span class="n">total_scores_N</span> <span class="o">/=</span> <span class="n">E</span>

    <span class="k">return</span> <span class="n">total_scores_N</span>
</pre></div>

    </div>
</div>
</div>

</div>
    {% endraw %}
# This is not working at the moment sadly :(((


def simple_compute_entropy(log_probs_N_K_C: torch.Tensor) -> torch.Tensor:
    N, K, C = log_probs_N_K_C.shape

    mean_log_probs_N_C = torch.logsumexp(log_probs_N_K_C.to(dtype=torch.double), dim=1) - math.log(K)
    nats_N_C = mean_log_probs_N_C * torch.exp(mean_log_probs_N_C)

    entropies_N = -torch.sum(nats_N_C, dim=1)

    return entropies_N


@torch.no_grad()
@torch.jit.script
def _get_real_naive_epig_scores(
    bootstrap_type: int,
    bootstrap_factor: float,
    pool_log_probs_N_K_C: torch.Tensor,
    eval_log_probs_E_K_C: torch.Tensor,
    dtype: int,
    device: torch.device,
) -> torch.Tensor:
    """Implements naive EPIG: I[Y_acq; Y_eval | x_acq, X_eval]."""
    # I[Y_acq; Y_eval | x_acq, X_eval] = H[Y_acq | x_acq] + E_p(x_eval)[H[Y_eval | x_eval] - H[Y_acq, Y_eval | x_acq, x_eval]]
    N, K, C = pool_log_probs_N_K_C.shape
    E, _, _ = eval_log_probs_E_K_C.shape
    assert (
        pool_log_probs_N_K_C.shape[1:] == pool_log_probs_N_K_C.shape[1:]
    ), "{pool_log_probs_N_K_C.shape[1:]} != {pool_log_probs_N_K_C.shape[1:]}"

    pool_entropies_N = simple_compute_entropy(pool_log_probs_N_K_C)

    pool_probs_N_K_C = pool_log_probs_N_K_C.to(dtype=dtype, device=device).exp()
    eval_probs_E_K_C = eval_log_probs_E_K_C.to(dtype=dtype, device=device).exp()

    total_joint_entropies_N = torch.zeros((N,), dtype=dtype, device="cpu")

    if bootstrap_type != 2:
        eval_label_uncertainty = simple_compute_entropy(eval_log_probs_E_K_C).mean(dim=0, keepdim=False)

        if bootstrap_type == 0:
            eval_range = torch.arange(E)
        elif bootstrap_type == 1:
            num_eval_samples = int(E * bootstrap_factor)
            eval_range = torch.multinomial(torch.tensor(1.0).expand(E), num_samples=num_eval_samples, replacement=True)
        else:
            raise ValueError(f"Unknown bootstrap {bootstrap_type}")

        for i_e in eval_range:
            single_eval_probs_K_C = eval_probs_E_K_C[i_e]

            joint_probs_N_C_C = get_joint_probs_N_C_C(pool_probs_N_K_C, single_eval_probs_K_C)
            weighted_nats_N_C_C = joint_probs_N_C_C * -torch.log(joint_probs_N_C_C)
            joint_entropy_N = weighted_nats_N_C_C.sum((1, 2), keepdim=False)
            # del weighted_nats_N_C_C

            total_joint_entropies_N += joint_entropy_N.to(device="cpu", non_blocking=True)

        total_scores_N = pool_entropies_N - total_joint_entropies_N / E + eval_label_uncertainty
    else:
        eval_label_uncertainty_E = simple_compute_entropy(eval_log_probs_E_K_C)

        total_scores_N = pool_entropies_N

        for i_n in range(N):
            single_pool_probs_K_C = pool_probs_N_K_C[i_n]

            num_eval_samples = int(E * bootstrap_factor)
            eval_indices = torch.multinomial(
                torch.tensor(1.0).expand(E), num_samples=num_eval_samples, replacement=True
            )
            # For debugging:
            # num_eval_samples = E
            # eval_indices = torch.tensor(list(range(E)))

            sampled_eval_probs_F_K_C = eval_probs_E_K_C[eval_indices]

            joint_probs_F_C_C = get_joint_probs_N_C_C(sampled_eval_probs_F_K_C, single_pool_probs_K_C)
            weighted_nats_F_C_C = joint_probs_F_C_C * -torch.log(joint_probs_F_C_C)
            avg_joint_entropy = weighted_nats_F_C_C.sum().to(device="cpu", non_blocking=True) / num_eval_samples
            # del weighted_nats_F_C_C

            eval_label_uncertainty = eval_label_uncertainty_E[eval_indices].mean(dim=0, keepdim=False)
            total_scores_N[i_n] += eval_label_uncertainty - avg_joint_entropy

    return total_scores_N


def get_real_naive_epig_scores(
    *,
    bootstrap_type=BootstrapType.NO_BOOTSTRAP,
    bootstrap_factor=1.0,
    pool_log_probs_N_K_C: torch.Tensor,
    eval_log_probs_E_K_C: torch.Tensor,
    dtype=torch.float,
    device=None,
) -> torch.Tensor:
    return _get_real_naive_epig_scores(
        bootstrap_type.value, bootstrap_factor, pool_log_probs_N_K_C, eval_log_probs_E_K_C, dtype, device
    )
    {% raw %}
    
<div class="cell border-box-sizing code_cell rendered">
<div class="input">

<div class="inner_cell">
    <div class="input_area">
<div class=" highlight hl-ipython3"><pre><span></span><span class="c1"># def logmatmulexp(log_A: torch.Tensor, log_B: torch.Tensor) -&gt; torch.Tensor:</span>
<span class="c1">#     &quot;&quot;&quot;Given matrix log_A of shape (batch...) ϴ×R and matrix log_B of shape R×I, calculates</span>
<span class="c1">#     (log_A.exp() @ log_B.exp()).log() and its backward in a numerically stable way.&quot;&quot;&quot;</span>
<span class="c1">#     batch_shape = list(log_A.shape[:-2])</span>
<span class="c1">#     ϴ, R = log_A.shape[-2:]</span>
<span class="c1">#     I = log_B.shape[-1]</span>
<span class="c1">#     assert log_B.shape == (R, I)</span>
<span class="c1">#     log_A_expanded = log_A.unsqueeze(-1).expand(batch_shape + [ϴ, R, I])</span>
<span class="c1">#     log_B_expanded = log_B.unsqueeze(-3).expand((ϴ, R, I))</span>
<span class="c1">#     log_pairwise_products = log_A_expanded + log_B_expanded  # shape: (ϴ, R, I)</span>
<span class="c1">#     return torch.logsumexp(log_pairwise_products, dim=-2)</span>


<span class="nd">@torch</span><span class="o">.</span><span class="n">no_grad</span><span class="p">()</span>
<span class="k">def</span> <span class="nf">logmatmulexp</span><span class="p">(</span><span class="n">log_A</span><span class="p">:</span> <span class="n">torch</span><span class="o">.</span><span class="n">Tensor</span><span class="p">,</span> <span class="n">log_B</span><span class="p">:</span> <span class="n">torch</span><span class="o">.</span><span class="n">Tensor</span><span class="p">)</span> <span class="o">-&gt;</span> <span class="n">torch</span><span class="o">.</span><span class="n">Tensor</span><span class="p">:</span>
    <span class="sd">&quot;&quot;&quot;Given matrix log_A of shape (batch...) ϴ×R and matrix log_B of shape R×I, calculates</span>
<span class="sd">    (log_A.exp() @ log_B.exp()).log() and its backward in a numerically stable way.&quot;&quot;&quot;</span>
    <span class="n">max_A</span> <span class="o">=</span> <span class="n">torch</span><span class="o">.</span><span class="n">max</span><span class="p">(</span><span class="n">log_A</span><span class="p">,</span> <span class="n">axis</span><span class="o">=-</span><span class="mi">1</span><span class="p">,</span> <span class="n">keepdim</span><span class="o">=</span><span class="kc">True</span><span class="p">)[</span><span class="mi">0</span><span class="p">]</span>
    <span class="n">max_B</span> <span class="o">=</span> <span class="n">torch</span><span class="o">.</span><span class="n">max</span><span class="p">(</span><span class="n">log_B</span><span class="p">,</span> <span class="n">axis</span><span class="o">=-</span><span class="mi">2</span><span class="p">,</span> <span class="n">keepdim</span><span class="o">=</span><span class="kc">True</span><span class="p">)[</span><span class="mi">0</span><span class="p">]</span>
    <span class="n">C</span> <span class="o">=</span> <span class="n">torch</span><span class="o">.</span><span class="n">log</span><span class="p">((</span><span class="n">log_A</span> <span class="o">-</span> <span class="n">max_A</span><span class="p">)</span><span class="o">.</span><span class="n">exp</span><span class="p">()</span> <span class="o">@</span> <span class="p">(</span><span class="n">log_B</span> <span class="o">-</span> <span class="n">max_B</span><span class="p">)</span><span class="o">.</span><span class="n">exp</span><span class="p">())</span> <span class="o">+</span> <span class="n">max_A</span> <span class="o">+</span> <span class="n">max_B</span>
    <span class="k">return</span> <span class="n">C</span>


<span class="nd">@torch</span><span class="o">.</span><span class="n">no_grad</span><span class="p">()</span>
<span class="k">def</span> <span class="nf">get_real_naive_epig_scores_stable</span><span class="p">(</span>
    <span class="o">*</span><span class="p">,</span>
    <span class="n">bootstrap_type</span><span class="o">=</span><span class="n">BootstrapType</span><span class="o">.</span><span class="n">NO_BOOTSTRAP</span><span class="p">,</span>
    <span class="n">bootstrap_factor</span><span class="o">=</span><span class="mf">1.0</span><span class="p">,</span>
    <span class="n">pool_log_probs_N_K_C</span><span class="p">:</span> <span class="n">torch</span><span class="o">.</span><span class="n">Tensor</span><span class="p">,</span>
    <span class="n">eval_log_probs_E_K_C</span><span class="p">:</span> <span class="n">torch</span><span class="o">.</span><span class="n">Tensor</span><span class="p">,</span>
    <span class="n">dtype</span><span class="o">=</span><span class="kc">None</span><span class="p">,</span>
    <span class="n">device</span><span class="o">=</span><span class="kc">None</span><span class="p">,</span>
<span class="p">)</span> <span class="o">-&gt;</span> <span class="n">torch</span><span class="o">.</span><span class="n">Tensor</span><span class="p">:</span>
    <span class="sd">&quot;&quot;&quot;Implements naive EPIG: I[Y_acq; Y_eval | x_acq, X_eval].&quot;&quot;&quot;</span>
    <span class="c1"># I[Y_acq; Y_eval | x_acq, X_eval] = H[Y_acq | x_acq] + E_p(x_eval)[H[Y_eval | x_eval] - H[Y_acq, Y_eval | x_acq, x_eval]]</span>
    <span class="n">N</span><span class="p">,</span> <span class="n">K</span><span class="p">,</span> <span class="n">C</span> <span class="o">=</span> <span class="n">pool_log_probs_N_K_C</span><span class="o">.</span><span class="n">shape</span>
    <span class="n">E</span><span class="p">,</span> <span class="n">_</span><span class="p">,</span> <span class="n">_</span> <span class="o">=</span> <span class="n">eval_log_probs_E_K_C</span><span class="o">.</span><span class="n">shape</span>
    <span class="k">assert</span> <span class="p">(</span>
        <span class="n">pool_log_probs_N_K_C</span><span class="o">.</span><span class="n">shape</span><span class="p">[</span><span class="mi">1</span><span class="p">:]</span> <span class="o">==</span> <span class="n">pool_log_probs_N_K_C</span><span class="o">.</span><span class="n">shape</span><span class="p">[</span><span class="mi">1</span><span class="p">:]</span>
    <span class="p">),</span> <span class="s2">&quot;</span><span class="si">{pool_log_probs_N_K_C.shape[1:]}</span><span class="s2"> != </span><span class="si">{pool_log_probs_N_K_C.shape[1:]}</span><span class="s2">&quot;</span>

    <span class="n">pool_entropies_N</span> <span class="o">=</span> <span class="n">compute_entropy</span><span class="p">(</span><span class="n">pool_log_probs_N_K_C</span><span class="p">)</span><span class="o">.</span><span class="n">to</span><span class="p">(</span><span class="n">device</span><span class="o">=</span><span class="n">device</span><span class="p">)</span>

    <span class="n">total_joint_entropies_N</span> <span class="o">=</span> <span class="n">torch</span><span class="o">.</span><span class="n">zeros</span><span class="p">((</span><span class="n">N</span><span class="p">,),</span> <span class="n">dtype</span><span class="o">=</span><span class="n">dtype</span><span class="p">,</span> <span class="n">device</span><span class="o">=</span><span class="n">device</span><span class="p">)</span>

    <span class="k">if</span> <span class="n">bootstrap_type</span> <span class="o">!=</span> <span class="n">BootstrapType</span><span class="o">.</span><span class="n">PER_POINT_BOOTSTRAP</span><span class="p">:</span>
        <span class="n">eval_label_uncertainty</span> <span class="o">=</span> <span class="n">compute_entropy</span><span class="p">(</span><span class="n">eval_log_probs_E_K_C</span><span class="p">)</span><span class="o">.</span><span class="n">mean</span><span class="p">(</span><span class="n">dim</span><span class="o">=</span><span class="mi">0</span><span class="p">,</span> <span class="n">keepdim</span><span class="o">=</span><span class="kc">False</span><span class="p">)</span>

        <span class="k">if</span> <span class="n">bootstrap_type</span> <span class="o">==</span> <span class="n">BootstrapType</span><span class="o">.</span><span class="n">NO_BOOTSTRAP</span><span class="p">:</span>
            <span class="n">eval_range</span> <span class="o">=</span> <span class="nb">range</span><span class="p">(</span><span class="n">E</span><span class="p">)</span>
        <span class="k">elif</span> <span class="n">bootstrap_type</span> <span class="o">==</span> <span class="n">BootstrapType</span><span class="o">.</span><span class="n">SINGLE_BOOTSTRAP</span><span class="p">:</span>
            <span class="n">num_eval_samples</span> <span class="o">=</span> <span class="nb">int</span><span class="p">(</span><span class="n">E</span> <span class="o">*</span> <span class="n">bootstrap_factor</span><span class="p">)</span>
            <span class="n">eval_range</span> <span class="o">=</span> <span class="n">torch</span><span class="o">.</span><span class="n">multinomial</span><span class="p">(</span><span class="n">torch</span><span class="o">.</span><span class="n">tensor</span><span class="p">(</span><span class="mf">1.0</span><span class="p">)</span><span class="o">.</span><span class="n">expand</span><span class="p">(</span><span class="n">E</span><span class="p">),</span> <span class="n">num_samples</span><span class="o">=</span><span class="n">num_eval_samples</span><span class="p">,</span> <span class="n">replacement</span><span class="o">=</span><span class="kc">True</span><span class="p">)</span>
        <span class="k">else</span><span class="p">:</span>
            <span class="k">raise</span> <span class="ne">ValueError</span><span class="p">(</span><span class="sa">f</span><span class="s2">&quot;Unknown bootstrap </span><span class="si">{</span><span class="n">bootstrap_type</span><span class="si">}</span><span class="s2">&quot;</span><span class="p">)</span>

        <span class="n">pool_log_probs_N_C_K</span> <span class="o">=</span> <span class="n">pool_log_probs_N_K_C</span><span class="o">.</span><span class="n">transpose</span><span class="p">(</span><span class="mi">1</span><span class="p">,</span> <span class="mi">2</span><span class="p">)</span><span class="o">.</span><span class="n">contiguous</span><span class="p">()</span><span class="o">.</span><span class="n">to</span><span class="p">(</span><span class="n">dtype</span><span class="o">=</span><span class="n">dtype</span><span class="p">,</span> <span class="n">device</span><span class="o">=</span><span class="n">device</span><span class="p">)</span>
        <span class="n">eval_log_probs_E_K_C</span> <span class="o">=</span> <span class="n">eval_log_probs_E_K_C</span><span class="o">.</span><span class="n">to</span><span class="p">(</span><span class="n">dtype</span><span class="o">=</span><span class="n">dtype</span><span class="p">,</span> <span class="n">device</span><span class="o">=</span><span class="n">device</span><span class="p">)</span>

        <span class="k">for</span> <span class="n">i_e</span> <span class="ow">in</span> <span class="n">with_progress_bar</span><span class="p">(</span><span class="n">eval_range</span><span class="p">,</span> <span class="n">tqdm_args</span><span class="o">=</span><span class="nb">dict</span><span class="p">(</span><span class="n">desc</span><span class="o">=</span><span class="s2">&quot;Evaluation Set&quot;</span><span class="p">,</span> <span class="n">leave</span><span class="o">=</span><span class="kc">False</span><span class="p">)):</span>
            <span class="n">single_eval_log_probs_K_C</span> <span class="o">=</span> <span class="n">eval_log_probs_E_K_C</span><span class="p">[</span><span class="n">i_e</span><span class="p">]</span>

            <span class="n">joint_probs_N_C_C</span> <span class="o">=</span> <span class="n">logmatmulexp</span><span class="p">(</span><span class="n">pool_log_probs_N_C_K</span><span class="p">,</span> <span class="n">single_eval_log_probs_K_C</span><span class="p">)</span> <span class="o">-</span> <span class="n">np</span><span class="o">.</span><span class="n">log</span><span class="p">(</span><span class="n">K</span><span class="p">)</span>
            <span class="n">weighted_nats_N_C_C</span> <span class="o">=</span> <span class="n">joint_probs_N_C_C</span> <span class="o">*</span> <span class="o">-</span><span class="n">torch</span><span class="o">.</span><span class="n">exp</span><span class="p">(</span><span class="n">joint_probs_N_C_C</span><span class="p">)</span>
            <span class="n">weighted_nats_N_C_C</span><span class="p">[</span><span class="n">torch</span><span class="o">.</span><span class="n">isnan</span><span class="p">(</span><span class="n">weighted_nats_N_C_C</span><span class="p">)]</span> <span class="o">=</span> <span class="mf">0.0</span>
            <span class="n">joint_entropy_N</span> <span class="o">=</span> <span class="n">weighted_nats_N_C_C</span><span class="o">.</span><span class="n">sum</span><span class="p">((</span><span class="mi">1</span><span class="p">,</span> <span class="mi">2</span><span class="p">),</span> <span class="n">keepdim</span><span class="o">=</span><span class="kc">False</span><span class="p">)</span>
            <span class="k">del</span> <span class="n">weighted_nats_N_C_C</span>

            <span class="n">total_joint_entropies_N</span> <span class="o">+=</span> <span class="n">joint_entropy_N</span>

        <span class="n">total_scores_N</span> <span class="o">=</span> <span class="n">pool_entropies_N</span> <span class="o">-</span> <span class="n">total_joint_entropies_N</span> <span class="o">/</span> <span class="n">E</span> <span class="o">+</span> <span class="n">eval_label_uncertainty</span>
    <span class="c1">#     elif bootstrap_type == BootstrapType.PER_POINT_BOOTSTRAP:</span>
    <span class="c1">#         eval_label_uncertainty_E = compute_entropy(eval_log_probs_E_K_C)</span>

    <span class="c1">#         total_scores_N = pool_entropies_N</span>

    <span class="c1">#         for i_n in with_progress_bar(range(N), tqdm_args=dict(desc=&quot;Pool Set&quot;, leave=False)):</span>
    <span class="c1">#             single_pool_probs_K_C = pool_probs_N_K_C[i_n]</span>

    <span class="c1">#             num_eval_samples = int(E * bootstrap_factor)</span>
    <span class="c1">#             eval_indices = torch.multinomial(</span>
    <span class="c1">#                 torch.tensor(1.0).expand(E), num_samples=num_eval_samples, replacement=True</span>
    <span class="c1">#             )</span>
    <span class="c1">#             # For debugging:</span>
    <span class="c1">#             # num_eval_samples = E</span>
    <span class="c1">#             # eval_indices = torch.tensor(list(range(E)))</span>

    <span class="c1">#             sampled_eval_probs_F_K_C = eval_probs_E_K_C[eval_indices]</span>

    <span class="c1">#             joint_probs_F_C_C = get_joint_probs_N_C_C(sampled_eval_probs_F_K_C, single_pool_probs_K_C)</span>
    <span class="c1">#             weighted_nats_F_C_C = joint_probs_F_C_C * -torch.log(joint_probs_F_C_C)</span>
    <span class="c1">#             avg_joint_entropy = weighted_nats_F_C_C.sum() / num_eval_samples</span>
    <span class="c1">#             del weighted_nats_F_C_C</span>

    <span class="c1">#             eval_label_uncertainty = eval_label_uncertainty_E[eval_indices].mean(dim=0, keepdim=False)</span>
    <span class="c1">#             total_scores_N[i_n] += eval_label_uncertainty - avg_joint_entropy</span>

    <span class="k">return</span> <span class="n">total_scores_N</span><span class="o">.</span><span class="n">to</span><span class="p">(</span><span class="n">device</span><span class="o">=</span><span class="s2">&quot;cpu&quot;</span><span class="p">,</span> <span class="n">non_blocking</span><span class="o">=</span><span class="kc">True</span><span class="p">)</span>
</pre></div>

    </div>
</div>
</div>

</div>
    {% endraw %}

    {% raw %}
    
<div class="cell border-box-sizing code_cell rendered">
<div class="input">

<div class="inner_cell">
    <div class="input_area">
<div class=" highlight hl-ipython3"><pre><span></span><span class="n">pool_log_probs_N_K_C</span> <span class="o">=</span> <span class="n">torch</span><span class="o">.</span><span class="n">log_softmax</span><span class="p">(</span><span class="n">torch</span><span class="o">.</span><span class="n">randn</span><span class="p">(</span><span class="mi">7</span><span class="p">,</span> <span class="mi">13</span><span class="p">,</span> <span class="mi">3</span><span class="p">)</span> <span class="o">*</span> <span class="mi">100</span><span class="p">,</span> <span class="n">dim</span><span class="o">=</span><span class="mi">2</span><span class="p">)</span>
<span class="n">eval_log_probs_E_K_C</span> <span class="o">=</span> <span class="n">torch</span><span class="o">.</span><span class="n">log_softmax</span><span class="p">(</span><span class="n">torch</span><span class="o">.</span><span class="n">randn</span><span class="p">(</span><span class="mi">11</span><span class="p">,</span> <span class="mi">13</span><span class="p">,</span> <span class="mi">3</span><span class="p">)</span> <span class="o">*</span> <span class="mi">100</span><span class="p">,</span> <span class="n">dim</span><span class="o">=</span><span class="mi">2</span><span class="p">)</span>
</pre></div>

    </div>
</div>
</div>

</div>
    {% endraw %}

    {% raw %}
    
<div class="cell border-box-sizing code_cell rendered">
<div class="input">

<div class="inner_cell">
    <div class="input_area">
<div class=" highlight hl-ipython3"><pre><span></span><span class="k">for</span> <span class="n">dtype</span> <span class="ow">in</span> <span class="p">(</span><span class="n">torch</span><span class="o">.</span><span class="n">float32</span><span class="p">,</span> <span class="n">torch</span><span class="o">.</span><span class="n">double</span><span class="p">):</span>
    <span class="nb">print</span><span class="p">(</span>
        <span class="n">get_real_naive_epig_scores</span><span class="p">(</span>
            <span class="n">pool_log_probs_N_K_C</span><span class="o">=</span><span class="n">pool_log_probs_N_K_C</span><span class="p">,</span>
            <span class="n">eval_log_probs_E_K_C</span><span class="o">=</span><span class="n">eval_log_probs_E_K_C</span><span class="p">,</span>
            <span class="n">device</span><span class="o">=</span><span class="s2">&quot;cuda&quot;</span><span class="p">,</span>
            <span class="n">dtype</span><span class="o">=</span><span class="n">dtype</span><span class="p">,</span>
        <span class="p">),</span>
        <span class="n">get_real_naive_epig_scores_stable</span><span class="p">(</span>
            <span class="n">pool_log_probs_N_K_C</span><span class="o">=</span><span class="n">pool_log_probs_N_K_C</span><span class="p">,</span>
            <span class="n">eval_log_probs_E_K_C</span><span class="o">=</span><span class="n">eval_log_probs_E_K_C</span><span class="p">,</span>
            <span class="n">device</span><span class="o">=</span><span class="s2">&quot;cuda&quot;</span><span class="p">,</span>
            <span class="n">dtype</span><span class="o">=</span><span class="n">dtype</span><span class="p">,</span>
        <span class="p">),</span>
    <span class="p">)</span>
</pre></div>

    </div>
</div>
</div>

<div class="output_wrapper">
<div class="output">

<div class="output_area">

<div class="output_subarea output_stream output_stdout output_text">
<pre>tensor([0.2034, 0.2925, 0.2823, 0.2413, 0.1856, 0.1703, 0.1390],
       dtype=torch.float64) tensor([0.2034, 0.2925, 0.2823, 0.2413, 0.1856, 0.1703, 0.1390],
       dtype=torch.float64)
tensor([0.2034, 0.2925, 0.2823, 0.2413, 0.1856, 0.1703, 0.1390],
       dtype=torch.float64) tensor([0.2034, 0.2925, 0.2823, 0.2413, 0.1856, 0.1703, 0.1390],
       dtype=torch.float64)
</pre>
</div>
</div>

</div>
</div>

</div>
    {% endraw %}

    {% raw %}
    
<div class="cell border-box-sizing code_cell rendered">
<div class="input">

<div class="inner_cell">
    <div class="input_area">
<div class=" highlight hl-ipython3"><pre><span></span><span class="n">get_real_naive_epig_scores</span><span class="p">(</span>
    <span class="n">pool_log_probs_N_K_C</span><span class="o">=</span><span class="n">pool_log_probs_N_K_C</span><span class="p">,</span> <span class="n">eval_log_probs_E_K_C</span><span class="o">=</span><span class="n">eval_log_probs_E_K_C</span><span class="p">,</span> <span class="n">device</span><span class="o">=</span><span class="s2">&quot;cuda&quot;</span>
<span class="p">),</span> <span class="n">get_real_naive_epig_scores_old</span><span class="p">(</span>
    <span class="n">pool_log_probs_N_K_C</span><span class="o">=</span><span class="n">pool_log_probs_N_K_C</span><span class="p">,</span> <span class="n">eval_log_probs_E_K_C</span><span class="o">=</span><span class="n">eval_log_probs_E_K_C</span><span class="p">,</span> <span class="n">device</span><span class="o">=</span><span class="s2">&quot;cuda&quot;</span>
<span class="p">)</span>
</pre></div>

    </div>
</div>
</div>

<div class="output_wrapper">
<div class="output">

<div class="output_area">



<div class="output_text output_subarea output_execute_result">
<pre>(tensor([0.2034, 0.2925, 0.2823, 0.2413, 0.1856, 0.1703, 0.1390],
        dtype=torch.float64),
 tensor([0.2034, 0.2925, 0.2823, 0.2413, 0.1856, 0.1703, 0.1390]))</pre>
</div>

</div>

</div>
</div>

</div>
    {% endraw %}

    {% raw %}
    
<div class="cell border-box-sizing code_cell rendered">
<div class="input">

<div class="inner_cell">
    <div class="input_area">
<div class=" highlight hl-ipython3"><pre><span></span><span class="n">get_real_naive_epig_scores</span><span class="p">(</span>
    <span class="n">bootstrap_type</span><span class="o">=</span><span class="n">BootstrapType</span><span class="o">.</span><span class="n">PER_POINT_BOOTSTRAP</span><span class="p">,</span>
    <span class="n">pool_log_probs_N_K_C</span><span class="o">=</span><span class="n">pool_log_probs_N_K_C</span><span class="p">,</span>
    <span class="n">eval_log_probs_E_K_C</span><span class="o">=</span><span class="n">eval_log_probs_E_K_C</span><span class="p">,</span>
    <span class="n">device</span><span class="o">=</span><span class="s2">&quot;cuda&quot;</span><span class="p">,</span>
<span class="p">)</span>
</pre></div>

    </div>
</div>
</div>

<div class="output_wrapper">
<div class="output">

<div class="output_area">



<div class="output_text output_subarea output_execute_result">
<pre>tensor([0.1770, 0.2326, 0.1526, 0.2323, 0.1525, 0.2118, 0.1741],
       dtype=torch.float64)</pre>
</div>

</div>

</div>
</div>

</div>
    {% endraw %}

    {% raw %}
    
<div class="cell border-box-sizing code_cell rendered">
<div class="input">

<div class="inner_cell">
    <div class="input_area">
<div class=" highlight hl-ipython3"><pre><span></span><span class="n">get_real_naive_epig_scores</span><span class="p">(</span>
    <span class="n">bootstrap_type</span><span class="o">=</span><span class="n">BootstrapType</span><span class="o">.</span><span class="n">SINGLE_BOOTSTRAP</span><span class="p">,</span>
    <span class="n">pool_log_probs_N_K_C</span><span class="o">=</span><span class="n">pool_log_probs_N_K_C</span><span class="p">,</span>
    <span class="n">eval_log_probs_E_K_C</span><span class="o">=</span><span class="n">eval_log_probs_E_K_C</span><span class="p">,</span>
    <span class="n">device</span><span class="o">=</span><span class="s2">&quot;cuda&quot;</span><span class="p">,</span>
<span class="p">)</span>
</pre></div>

    </div>
</div>
</div>

<div class="output_wrapper">
<div class="output">

<div class="output_area">



<div class="output_text output_subarea output_execute_result">
<pre>tensor([0.1971, 0.1683, 0.1589, 0.1959, 0.1634, 0.2245, 0.1531],
       dtype=torch.float64)</pre>
</div>

</div>

</div>
</div>

</div>
    {% endraw %}

    {% raw %}
    
<div class="cell border-box-sizing code_cell rendered">
<div class="input">

<div class="inner_cell">
    <div class="input_area">
<div class=" highlight hl-ipython3"><pre><span></span><span class="n">num_samples</span> <span class="o">=</span> <span class="mi">60000</span>

<span class="k">with</span> <span class="n">torch</span><span class="o">.</span><span class="n">no_grad</span><span class="p">():</span>
    <span class="n">X</span> <span class="o">=</span> <span class="n">torch</span><span class="o">.</span><span class="n">log_softmax</span><span class="p">(</span><span class="n">torch</span><span class="o">.</span><span class="n">randn</span><span class="p">(</span><span class="n">num_samples</span><span class="p">,</span> <span class="mi">100</span><span class="p">,</span> <span class="mi">10</span><span class="p">),</span> <span class="n">dim</span><span class="o">=</span><span class="mi">2</span><span class="p">)</span>
    <span class="n">Y</span> <span class="o">=</span> <span class="n">torch</span><span class="o">.</span><span class="n">log_softmax</span><span class="p">(</span><span class="n">torch</span><span class="o">.</span><span class="n">randn</span><span class="p">(</span><span class="n">num_samples</span><span class="p">,</span> <span class="mi">100</span><span class="p">,</span> <span class="mi">10</span><span class="p">),</span> <span class="n">dim</span><span class="o">=</span><span class="mi">2</span><span class="p">)</span>
    <span class="n">get_real_naive_epig_scores</span><span class="p">(</span>
        <span class="n">pool_log_probs_N_K_C</span><span class="o">=</span><span class="n">X</span><span class="p">,</span>
        <span class="n">eval_log_probs_E_K_C</span><span class="o">=</span><span class="n">Y</span><span class="p">,</span>
        <span class="n">dtype</span><span class="o">=</span><span class="n">torch</span><span class="o">.</span><span class="n">double</span><span class="p">,</span>
        <span class="n">device</span><span class="o">=</span><span class="s2">&quot;cuda&quot;</span><span class="p">,</span>
    <span class="p">)</span>
</pre></div>

    </div>
</div>
</div>

<div class="output_wrapper">
<div class="output">

<div class="output_area">

<div class="output_subarea output_text output_error">
<pre>
<span class="ansi-red-fg">---------------------------------------------------------------------------</span>
<span class="ansi-red-fg">KeyboardInterrupt</span>                         Traceback (most recent call last)
<span class="ansi-green-fg">&lt;ipython-input-71-9af49b935316&gt;</span> in <span class="ansi-cyan-fg">&lt;module&gt;</span>
<span class="ansi-green-intense-fg ansi-bold">      6</span>     X <span class="ansi-blue-fg">=</span> torch<span class="ansi-blue-fg">.</span>log_softmax<span class="ansi-blue-fg">(</span>torch<span class="ansi-blue-fg">.</span>randn<span class="ansi-blue-fg">(</span>num_samples<span class="ansi-blue-fg">,</span> <span class="ansi-cyan-fg">100</span><span class="ansi-blue-fg">,</span> <span class="ansi-cyan-fg">10</span><span class="ansi-blue-fg">)</span><span class="ansi-blue-fg">,</span> dim<span class="ansi-blue-fg">=</span><span class="ansi-cyan-fg">2</span><span class="ansi-blue-fg">)</span>
<span class="ansi-green-intense-fg ansi-bold">      7</span>     Y <span class="ansi-blue-fg">=</span> torch<span class="ansi-blue-fg">.</span>log_softmax<span class="ansi-blue-fg">(</span>torch<span class="ansi-blue-fg">.</span>randn<span class="ansi-blue-fg">(</span>num_samples<span class="ansi-blue-fg">,</span> <span class="ansi-cyan-fg">100</span><span class="ansi-blue-fg">,</span> <span class="ansi-cyan-fg">10</span><span class="ansi-blue-fg">)</span><span class="ansi-blue-fg">,</span> dim<span class="ansi-blue-fg">=</span><span class="ansi-cyan-fg">2</span><span class="ansi-blue-fg">)</span>
<span class="ansi-green-fg">----&gt; 8</span><span class="ansi-red-fg">     get_real_naive_epig_scores_old(
</span><span class="ansi-green-intense-fg ansi-bold">      9</span>         pool_log_probs_N_K_C<span class="ansi-blue-fg">=</span>X<span class="ansi-blue-fg">,</span>
<span class="ansi-green-intense-fg ansi-bold">     10</span>         eval_log_probs_E_K_C<span class="ansi-blue-fg">=</span>Y<span class="ansi-blue-fg">,</span>

<span class="ansi-green-fg">&lt;ipython-input-54-3282b1f8025e&gt;</span> in <span class="ansi-cyan-fg">get_real_naive_epig_scores_old</span><span class="ansi-blue-fg">(pool_log_probs_N_K_C, eval_log_probs_E_K_C, dtype, device)</span>
<span class="ansi-green-intense-fg ansi-bold">     37</span> 
<span class="ansi-green-intense-fg ansi-bold">     38</span>         weighted_nats_N_C_C <span class="ansi-blue-fg">=</span> nats_N_C_C <span class="ansi-blue-fg">*</span> joint_probs_N_C_C
<span class="ansi-green-fg">---&gt; 39</span><span class="ansi-red-fg">         </span>weighted_nats_N_C_C<span class="ansi-blue-fg">[</span>torch<span class="ansi-blue-fg">.</span>isnan<span class="ansi-blue-fg">(</span>weighted_nats_N_C_C<span class="ansi-blue-fg">)</span><span class="ansi-blue-fg">]</span> <span class="ansi-blue-fg">=</span> <span class="ansi-cyan-fg">0.0</span>
<span class="ansi-green-intense-fg ansi-bold">     40</span>         scores_N <span class="ansi-blue-fg">=</span> weighted_nats_N_C_C<span class="ansi-blue-fg">.</span>sum<span class="ansi-blue-fg">(</span><span class="ansi-blue-fg">(</span><span class="ansi-cyan-fg">1</span><span class="ansi-blue-fg">,</span> <span class="ansi-cyan-fg">2</span><span class="ansi-blue-fg">)</span><span class="ansi-blue-fg">,</span> keepdim<span class="ansi-blue-fg">=</span><span class="ansi-green-fg">False</span><span class="ansi-blue-fg">)</span>
<span class="ansi-green-intense-fg ansi-bold">     41</span> 

<span class="ansi-red-fg">KeyboardInterrupt</span>: </pre>
</div>
</div>

</div>
</div>

</div>
    {% endraw %}

<div class="cell border-box-sizing text_cell rendered"><div class="inner_cell">
<div class="text_cell_render border-box-sizing rendered_html">
<h1 id="slow">slow<a class="anchor-link" href="#slow"> </a></h1><p>num_samples = 6000</p>
<p>with torch.no_grad():
    get_real_naive_epig_scores_old(
        pool_log_probs_N_K_C=X,
        eval_log_probs_E_K_C=Y,
        dtype=torch.float,
        device="cuda",
    )</p>

</div>
</div>
</div>
    {% raw %}
    
<div class="cell border-box-sizing code_cell rendered">
<div class="input">

<div class="inner_cell">
    <div class="input_area">
<div class=" highlight hl-ipython3"><pre><span></span><span class="k">with</span> <span class="n">torch</span><span class="o">.</span><span class="n">no_grad</span><span class="p">():</span>
    <span class="n">get_real_naive_epig_scores</span><span class="p">(</span>
        <span class="n">bootstrap_type</span><span class="o">=</span><span class="n">BootstrapType</span><span class="o">.</span><span class="n">PER_POINT_BOOTSTRAP</span><span class="p">,</span>
        <span class="n">bootstrap_factor</span><span class="o">=</span><span class="mi">1</span><span class="p">,</span>
        <span class="n">pool_log_probs_N_K_C</span><span class="o">=</span><span class="n">torch</span><span class="o">.</span><span class="n">log_softmax</span><span class="p">(</span><span class="n">torch</span><span class="o">.</span><span class="n">randn</span><span class="p">(</span><span class="n">num_samples</span><span class="p">,</span> <span class="mi">100</span><span class="p">,</span> <span class="mi">10</span><span class="p">),</span> <span class="n">dim</span><span class="o">=</span><span class="mi">2</span><span class="p">),</span>
        <span class="n">eval_log_probs_E_K_C</span><span class="o">=</span><span class="n">torch</span><span class="o">.</span><span class="n">log_softmax</span><span class="p">(</span><span class="n">torch</span><span class="o">.</span><span class="n">randn</span><span class="p">(</span><span class="n">num_samples</span><span class="p">,</span> <span class="mi">100</span><span class="p">,</span> <span class="mi">10</span><span class="p">),</span> <span class="n">dim</span><span class="o">=</span><span class="mi">2</span><span class="p">),</span>
        <span class="n">device</span><span class="o">=</span><span class="s2">&quot;cuda&quot;</span><span class="p">,</span>
    <span class="p">)</span>
</pre></div>

    </div>
</div>
</div>

</div>
    {% endraw %}

    {% raw %}
    
<div class="cell border-box-sizing code_cell rendered">
<div class="input">

<div class="inner_cell">
    <div class="input_area">
<div class=" highlight hl-ipython3"><pre><span></span><span class="k">with</span> <span class="n">torch</span><span class="o">.</span><span class="n">no_grad</span><span class="p">():</span>
    <span class="n">get_real_naive_epig_scores</span><span class="p">(</span>
        <span class="n">bootstrap_type</span><span class="o">=</span><span class="n">BootstrapType</span><span class="o">.</span><span class="n">SINGLE_BOOTSTRAP</span><span class="p">,</span>
        <span class="n">bootstrap_factor</span><span class="o">=</span><span class="mf">0.85</span><span class="p">,</span>
        <span class="n">pool_log_probs_N_K_C</span><span class="o">=</span><span class="n">torch</span><span class="o">.</span><span class="n">log_softmax</span><span class="p">(</span><span class="n">torch</span><span class="o">.</span><span class="n">randn</span><span class="p">(</span><span class="n">num_samples</span><span class="p">,</span> <span class="mi">100</span><span class="p">,</span> <span class="mi">10</span><span class="p">),</span> <span class="n">dim</span><span class="o">=</span><span class="mi">2</span><span class="p">),</span>
        <span class="n">eval_log_probs_E_K_C</span><span class="o">=</span><span class="n">torch</span><span class="o">.</span><span class="n">log_softmax</span><span class="p">(</span><span class="n">torch</span><span class="o">.</span><span class="n">randn</span><span class="p">(</span><span class="n">num_samples</span><span class="p">,</span> <span class="mi">100</span><span class="p">,</span> <span class="mi">10</span><span class="p">),</span> <span class="n">dim</span><span class="o">=</span><span class="mi">2</span><span class="p">),</span>
        <span class="n">device</span><span class="o">=</span><span class="s2">&quot;cuda&quot;</span><span class="p">,</span>
    <span class="p">)</span>
</pre></div>

    </div>
</div>
</div>

</div>
    {% endraw %}

</div>
 

